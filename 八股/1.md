0、C++内存模型
C++程序在运行时的内存情况
1）代码区 代码区又分为指令段和只读数据段
    1.指令段即存储机器指令的部分
    2.只读数据存储常量数据如字符串常量、全局或静态变量的初始值

两个特点
    1.只读，保证程序执行期间数据的一致和安全性
    2.可复用，多个程序可共享？（这不是动态链接库的能力吗）

2）常量存储区
包括字符串常量、全局常量、const修饰的全局/局部变量
这些数据在程序执行期间不可修改

3）全局/静态存储区
存储全局变量，在函数外部声明，可被整个程序访问
静态变量比较特殊，其可见范围与一般变量相同，但实际上只会被初始化一次
```c++
void Test()
{
    static int num = 10;
    num++;
}
```

4）栈
5）堆

1、实现memmove
什么是memmove，标准库函数，用于内存复制。类似的有memcopy。
如果源内存和目标内存有重叠，使用memcopy可能有未定义行为，使用memmove是安全的。

2、菱形继承
一个类继承多个类，这些多个类有共同父类

产生的问题：
    1.对共同父类中的成员属性和方法可能有二义性
    2.也浪费了存储空间
    底部类可以在每个中间类中找到同名成员与方法，值的存储空间不同，方法的实现也不同

解决办法
C++解决菱形继承的方式是虚继承，底部类只继承一次顶部类，这样成员变量只会有一个

实现原理
    通过虚表偏移实现继承
    中间类的vptr都有到共同基类的偏移量，从而底部类从多个中间类的通路到达的都是同一个顶部类

```c++
class A {
public:
    int age;
    void func() {
        std::cout << "A::func()" << std::endl;
    }
};

class B : virtual public A {
public:
    void func() {
        std::cout << "B::func()" << std::endl;
    }
};

class C : virtual public A {
public:
    void func() {
        std::cout << "C::func()" << std::endl;
    }
};

class D : virtual public B, virtual public C {
public:
    void func() {
        std::cout << "D::func()" << std::endl;
    }
};
```




3、多态的实现原理 
1）静态多态
    函数重载，编译器确定。在同一作用域中的同名函数，参数列表不同（个数、类型、顺序）
    原理：函数名修饰
    
编译过程：
    预编译     把头文件中的函数声明拷贝到源文件中，避免编译过程中的语法分析找不到函数定义
    编译       语法分析，同时进行符号汇总（函数名）
    汇编       生成函数名与函数地址的映射，用于通过函数名找到定义位置
    链接       将多个文件中的符号表汇总合并

2）动态多态

