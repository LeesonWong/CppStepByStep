0、C++内存模型
C++程序在运行时的内存情况
1）代码区 代码区又分为指令段和只读数据段
1.指令段即存储机器指令的部分
2.只读数据存储常量数据如字符串常量、全局或静态变量的初始值

两个特点
1.只读，保证程序执行期间数据的一致和安全性
2.可复用，多个程序可共享？（这不是动态链接库的能力吗）

2）常量存储区
包括字符串常量、全局常量、const修饰的全局/局部变量
这些数据在程序执行期间不可修改

3）全局/静态存储区
存储全局变量，在函数外部声明，可被整个程序访问
静态变量比较特殊，其可见范围与一般变量相同，但实际上只会被初始化一次

```c++
void Test()
{
    static int num = 10;
    num++;
}
```

4）栈
5）堆

1、实现memmove
什么是memmove，标准库函数，用于内存复制。类似的有memcopy。
如果源内存和目标内存有重叠，使用memcopy可能有未定义行为，使用memmove是安全的。

2、菱形继承
一个类继承多个类，这些多个类有共同父类

产生的问题：
1.对共同父类中的成员属性和方法可能有二义性
2.也浪费了存储空间
底部类可以在每个中间类中找到同名成员与方法，值的存储空间不同，方法的实现也不同

解决办法
C++解决菱形继承的方式是虚继承，底部类只继承一次顶部类，这样成员变量只会有一个

实现原理
通过虚表偏移实现继承
中间类的vptr都有到共同基类的偏移量，从而底部类从多个中间类的通路到达的都是同一个顶部类

```c++
class A {
public:
    int age;
    void func() {
        std::cout << "A::func()" << std::endl;
    }
};

class B : virtual public A {
public:
    void func() {
        std::cout << "B::func()" << std::endl;
    }
};

class C : virtual public A {
public:
    void func() {
        std::cout << "C::func()" << std::endl;
    }
};

class D : virtual public B, virtual public C {
public:
    void func() {
        std::cout << "D::func()" << std::endl;
    }
};
```

3、多态的实现原理
1）静态多态
函数重载，编译器确定。在同一作用域中的同名函数，参数列表不同（个数、类型、顺序）
原理：函数名修饰

编译过程：
预编译 把头文件中的函数声明拷贝到源文件中，避免编译过程中的语法分析找不到函数定义
编译 语法分析，同时进行符号汇总（函数名）
汇编 生成函数名与函数地址的映射，用于通过函数名找到定义位置
链接 将多个文件中的符号表汇总合并

2）动态多态

4、函数参数传递的方式和特点
值传递
会产生对象拷贝的开销

引用传递、指针传递

5、static和const的区别

static
static修饰的局部变量、全局变量、函数、类都有什么特点
1）局部静态变量，生命周期与程序相同，函数执行完毕后值依然存在

2）全局静态变量，只针对当前文件可见

3）静态成员变量 面向对象的标准内容

4）函数
TODO

5）类
TODO

6、C++和C的区别

| 特性    | C++               | C                   |
|-------|-------------------|---------------------|
| 设计哲学  | 面向对象与过程杂糅         | 面向过程                |
| 核心结构  | 以类为核心             | 以结构体为核心             |
| 多态性   | 原生支持，通过虚函数实现运行期多态 | 通过宏定义实现类似功能         |
| 封装性   | 支持访问修饰符           | 不支持访问修饰符            |
| 继承性   | 支持类继承             | 不支持，可以通过结构体模拟       |
| 内存管理  | 支持自动管理内存的方式，如智能指针 | 需要手动管理内存            |
| 异常处理  | 支持try-catch机制     | 不直接支持异常处理，通常使用错误码表示 |
| 标准库   |                   |                     |
| 模板与泛型 |                   |                     |
| 跨平台   |                   |                     |
| 效率    |                   |                     |

7、new和malloc，free和delete的区别
结构、表现形式服务于内容

相同点，都是主动分配内存的手段，程序员主动分配内存都在堆上

不同点
这两种分配内存的最终目的是相同的，都是使用一片内存空间存储数据。C++添加了面向对象特性，通过new和free分配符合对象大小的内存空间。
1）new分配符合对象大小的空间，malloc需要指定大小
2）new会调用构造。因C++面向对象特性，new本意是创建对象，创建对象后需要存储，也就需要再堆上分配适当大小的内存

8、指针和引用的区别
从汇编实现上来说，大多编译器指针和引用的解释是一样的。功能目标上不一样

9、深拷贝和浅拷贝
浅拷贝
重新创建一个对象，成员仍指向原对象的成员

深拷贝
重新创建对象，并创建原对象的成员对象

|       | 深拷贝                 | 浅拷贝             |
|-------|---------------------|-----------------|
| 内容复制  | 复制对象的具体内容，包括引用的其他对象 | 仅赋值对象的值和引用的内存地址 |
| 内存地址  |                     |                 |
| 对象独立性 | 新对象和原对象完全独立         | 新对象与原对象共享某些内存空间 |
| 适用场景  |                     |                 |

10、进程间通信，管道的特点
进程间通信 IPC（Inter-Process Communication）
进程间通信的方式，消息队列、共享内存、管道（Pipe）
说到进程，就必须与操作系统打交道，语言本身提供了适合的API也可能没有。最重要的是操作系统本身要支持进程间通信，语言才可能对系统提供的API进行封装。

11、内存泄漏如何检测
内存泄漏是严重的编程问题，它通常发生在动态分配的内存灭有被正确释放时。这会导致占用内存持续增长，最终可能资源耗尽。

1）工具检测

2）静态检查

12、虚函数、虚函数表、虚指针 / C++的继承和多态
先有顶层设计后有实现，先有面向对象标准后有语言适配
C++为了实现面向对象特性的封装、继承和多态


13、指针变量的大小
指针变量的内容表示内存地址位置，位置的表示能力也就是使用CPU的寻址能力，同时取决于操作系统的位数
例如
32位操作系统，可表示最多可以表示4G内存
B1 K10 M20 G30

64位操作系统，可表示最多可以表示2^24T内存
B1 K10 M20 G30 T40

所以对应的指针变量大小也就是32位/4B或者64位/8B

14、explicit的作用
可出现在构造函数前面，目的是防止类构造函数的意外调用，防止隐式类型转换

这种类型转换会发生在右边的值或者{}与构造函数的参数列表相同时发生，explicit会禁止这种构造方式


15、C与CPP的不同点

|            | C         | CPP               |
|------------|-----------|-------------------|
| 面向对象特性     | 主要以函数组织代码 | 实现了OOP规范，引入封装继承多态 |
| 数据抽象和封装    |           |                   |
| 函数重载和运算符重载 |           |                   |
| 命名空间       |           |                   |
| 内存管理       |           |                   |
| 标准库差异      |           |                   |
| 异常处理       |           |                   |


16、constexpr
constexpr表达式是指值不会变化且在编译过程中就能得到计算结果的表达式
constexpr变量一定是const变量